<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>posnk kernel: VFS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">posnk kernel
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="https://github.com/peterbjornx/posnk"><span>GitHub&#160;Project</span></a></li>
      <li><a href="downloads.html"><span>Downloads</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__vfs.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">VFS</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Virtual File System layer provides abstraction between the rest of the kernel and the FS drivers, it handles path resolution, filesystem mounts and all special file types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac1913485037320335c4030439d537df8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#gac1913485037320335c4030439d537df8">vfs_initialize</a> (<a class="el" href="group__vfs.html#ga616bc6ee0262218ac3507c48556a1e6f">fs_device_t</a> *root_device)</td></tr>
<tr class="memdesc:gac1913485037320335c4030439d537df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the VFS layer.  <a href="#gac1913485037320335c4030439d537df8"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structinode.html">inode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a file currently cached by the kernel.  <a href="structinode.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdirent.html">dirent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a directory entry in a portable FS independent format.  <a href="structdirent.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdir__cache.html">dir_cache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entry in the path element cache The kernel keeps track of these to resolve the .  <a href="structdir__cache.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__device__operations.html">fs_device_operations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains callbacks for all filesystem driver functions.  <a href="structfs__device__operations.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__device.html">fs_device</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance of a filesystem driver.  <a href="structfs__device.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac4d1baf108e9ce6414088db508d7c182"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#gac4d1baf108e9ce6414088db508d7c182">MODE_READ</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:gac4d1baf108e9ce6414088db508d7c182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit definition for inode-&gt;mode, this file is readable.  <a href="#gac4d1baf108e9ce6414088db508d7c182"></a><br/></td></tr>
<tr class="memitem:gab8fac4c725bb7d4b05ae138c07ef54af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#gab8fac4c725bb7d4b05ae138c07ef54af">MODE_WRITE</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:gab8fac4c725bb7d4b05ae138c07ef54af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit definition for inode-&gt;mode, this file is writable.  <a href="#gab8fac4c725bb7d4b05ae138c07ef54af"></a><br/></td></tr>
<tr class="memitem:ga2ab5cedebe651b3858703af1d8301993"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga2ab5cedebe651b3858703af1d8301993">MODE_EXEC</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga2ab5cedebe651b3858703af1d8301993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit definition for inode-&gt;mode, this file is executable/searchable.  <a href="#ga2ab5cedebe651b3858703af1d8301993"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
VFS API</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp022827e3f9d752c6886f0eae7da31390"></a>Public VFS functions </p>
</td></tr>
<tr class="memitem:ga3494d0da607504093448c9fbc5d2623e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga3494d0da607504093448c9fbc5d2623e">vfs_inode_release</a> (<a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *<a class="el" href="structinode.html">inode</a>)</td></tr>
<tr class="memdesc:ga3494d0da607504093448c9fbc5d2623e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a reference to an inode.  <a href="#ga3494d0da607504093448c9fbc5d2623e"></a><br/></td></tr>
<tr class="memitem:gaa8336c694b79fb0e56847ab2e1b26750"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#gaa8336c694b79fb0e56847ab2e1b26750">vfs_find_parent</a> (char *path)</td></tr>
<tr class="memdesc:gaa8336c694b79fb0e56847ab2e1b26750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the inode for the directory containing the file.  <a href="#gaa8336c694b79fb0e56847ab2e1b26750"></a><br/></td></tr>
<tr class="memitem:ga60e197d9a65de9d15c88f8fa1f6e7c97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga60e197d9a65de9d15c88f8fa1f6e7c97">vfs_find_inode</a> (char *path)</td></tr>
<tr class="memdesc:ga60e197d9a65de9d15c88f8fa1f6e7c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the inode for the file referenced by path.  <a href="#ga60e197d9a65de9d15c88f8fa1f6e7c97"></a><br/></td></tr>
<tr class="memitem:ga5b390b5f69c09ba25d6ecec740c301d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga5b390b5f69c09ba25d6ecec740c301d1">vfs_find_symlink</a> (char *path)</td></tr>
<tr class="memdesc:ga5b390b5f69c09ba25d6ecec740c301d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the inode for the file referenced by path, not dereferencing symlinks or mounts.  <a href="#ga5b390b5f69c09ba25d6ecec740c301d1"></a><br/></td></tr>
<tr class="memitem:ga489abb04eb8e74a3f11a0a20f32a845c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__vfs.html#ga6673e8f64ca9ebd7e26e6289dca06e87">dirent_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga489abb04eb8e74a3f11a0a20f32a845c">vfs_find_dirent</a> (<a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *<a class="el" href="structinode.html">inode</a>, char *name)</td></tr>
<tr class="memdesc:ga489abb04eb8e74a3f11a0a20f32a845c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a directory entry.  <a href="#ga489abb04eb8e74a3f11a0a20f32a845c"></a><br/></td></tr>
<tr class="memitem:ga6187be67e690be6916a385ebde588093"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga6187be67e690be6916a385ebde588093">vfs_rmdir</a> (char *path)</td></tr>
<tr class="memdesc:ga6187be67e690be6916a385ebde588093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a directory.  <a href="#ga6187be67e690be6916a385ebde588093"></a><br/></td></tr>
<tr class="memitem:ga22ee4ff0cc661e9246bd6a76702b298e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga22ee4ff0cc661e9246bd6a76702b298e">vfs_mkdir</a> (char *path, <a class="el" href="types_8h.html#a161c505f18322d8ce974064784be272a">mode_t</a> mode)</td></tr>
<tr class="memdesc:ga22ee4ff0cc661e9246bd6a76702b298e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory.  <a href="#ga22ee4ff0cc661e9246bd6a76702b298e"></a><br/></td></tr>
<tr class="memitem:ga1833cb4e7ef568776472b7d940eccf04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga1833cb4e7ef568776472b7d940eccf04">vfs_mknod</a> (char *path, <a class="el" href="types_8h.html#a161c505f18322d8ce974064784be272a">mode_t</a> mode, <a class="el" href="types_8h.html#a31acaaf3092d869de3b5e34d11695520">dev_t</a> dev)</td></tr>
<tr class="memdesc:ga1833cb4e7ef568776472b7d940eccf04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a file.  <a href="#ga1833cb4e7ef568776472b7d940eccf04"></a><br/></td></tr>
<tr class="memitem:ga797ee30a843cc96fdb59db73fe97102d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga797ee30a843cc96fdb59db73fe97102d">vfs_unlink</a> (char *path)</td></tr>
<tr class="memdesc:ga797ee30a843cc96fdb59db73fe97102d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a file.  <a href="#ga797ee30a843cc96fdb59db73fe97102d"></a><br/></td></tr>
<tr class="memitem:gac8b32bb45661974629d18b9830c5d026"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#gac8b32bb45661974629d18b9830c5d026">vfs_link</a> (char *oldpath, char *newpath)</td></tr>
<tr class="memdesc:gac8b32bb45661974629d18b9830c5d026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a hard link.  <a href="#gac8b32bb45661974629d18b9830c5d026"></a><br/></td></tr>
<tr class="memitem:ga5525864c8ec0cc591c31faf9e0b7636d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga5525864c8ec0cc591c31faf9e0b7636d">vfs_symlink</a> (char *oldpath, char *newpath)</td></tr>
<tr class="memdesc:ga5525864c8ec0cc591c31faf9e0b7636d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a symbolic link.  <a href="#ga5525864c8ec0cc591c31faf9e0b7636d"></a><br/></td></tr>
<tr class="memitem:ga61886b169216dc8c85945584536fbb1d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga61886b169216dc8c85945584536fbb1d">vfs_mount</a> (char *device, char *mountpoint, char *fstype, uint32_t flags)</td></tr>
<tr class="memdesc:ga61886b169216dc8c85945584536fbb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mount a filesystem.  <a href="#ga61886b169216dc8c85945584536fbb1d"></a><br/></td></tr>
<tr class="memitem:gab379ab04ee753835803908fe8e2390ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#gab379ab04ee753835803908fe8e2390ed">vfs_write</a> (<a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *<a class="el" href="structinode.html">inode</a>, <a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a> file_offset, void *buffer, <a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a> count, <a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a> *read_size, int non_block)</td></tr>
<tr class="memdesc:gab379ab04ee753835803908fe8e2390ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a file.  <a href="#gab379ab04ee753835803908fe8e2390ed"></a><br/></td></tr>
<tr class="memitem:ga3b462cea173d8cd38ab8b46b98a159d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga3b462cea173d8cd38ab8b46b98a159d7">vfs_read</a> (<a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *<a class="el" href="structinode.html">inode</a>, <a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a> file_offset, void *buffer, <a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a> count, <a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a> *read_size, int non_block)</td></tr>
<tr class="memdesc:ga3b462cea173d8cd38ab8b46b98a159d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from a file.  <a href="#ga3b462cea173d8cd38ab8b46b98a159d7"></a><br/></td></tr>
<tr class="memitem:ga94b66b2d752c243c35894d6655626566"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga94b66b2d752c243c35894d6655626566">vfs_getdents</a> (<a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *<a class="el" href="structinode.html">inode</a>, <a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a> file_offset, <a class="el" href="group__vfs.html#ga6673e8f64ca9ebd7e26e6289dca06e87">dirent_t</a> *buffer, <a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a> count, <a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a> *read_size)</td></tr>
<tr class="memdesc:ga94b66b2d752c243c35894d6655626566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read directory entries.  <a href="#ga94b66b2d752c243c35894d6655626566"></a><br/></td></tr>
<tr class="memitem:ga9913748fc23c6bfe9d775a2f27d82228"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga9913748fc23c6bfe9d775a2f27d82228">vfs_truncate</a> (<a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *<a class="el" href="structinode.html">inode</a>, <a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a> length)</td></tr>
<tr class="memdesc:ga9913748fc23c6bfe9d775a2f27d82228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a file.  <a href="#ga9913748fc23c6bfe9d775a2f27d82228"></a><br/></td></tr>
<tr class="memitem:gaaf38fb9429e180341bada6ddd3f3c22a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#gaaf38fb9429e180341bada6ddd3f3c22a">vfs_chroot</a> (<a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a> *dirc)</td></tr>
<tr class="memdesc:gaaf38fb9429e180341bada6ddd3f3c22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the root directory for this process.  <a href="#gaaf38fb9429e180341bada6ddd3f3c22a"></a><br/></td></tr>
<tr class="memitem:gac950be0dca83a86499018b8c6372b352"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#gac950be0dca83a86499018b8c6372b352">vfs_chdir</a> (<a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a> *dirc)</td></tr>
<tr class="memdesc:gac950be0dca83a86499018b8c6372b352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the working directory for this process.  <a href="#gac950be0dca83a86499018b8c6372b352"></a><br/></td></tr>
<tr class="memitem:gaf09508470980cccac2b4a2b86cd0c716"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#gaf09508470980cccac2b4a2b86cd0c716">vfs_get_filename</a> (const char *path)</td></tr>
<tr class="memdesc:gaf09508470980cccac2b4a2b86cd0c716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the filename part of a path.  <a href="#gaf09508470980cccac2b4a2b86cd0c716"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="member-group"></a>
VFS Internal</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp00b71846bac31c4973c8ad23d50f7559"></a>Utility functions for use by VFS functions only </p>
</td></tr>
<tr class="memitem:ga9fd0a37c12ffd599dfa7b698180c9a5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga9fd0a37c12ffd599dfa7b698180c9a5f">vfs_dir_cache_mkroot</a> (<a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *root_inode)</td></tr>
<tr class="memdesc:ga9fd0a37c12ffd599dfa7b698180c9a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the initial dir cache entry.  <a href="#ga9fd0a37c12ffd599dfa7b698180c9a5f"></a><br/></td></tr>
<tr class="memitem:gab983aeeac1801fd1bac9c8074b2c4358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#gab983aeeac1801fd1bac9c8074b2c4358">vfs_dir_cache_release</a> (<a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a> *dirc)</td></tr>
<tr class="memdesc:gab983aeeac1801fd1bac9c8074b2c4358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a reference to a directory cache entry.  <a href="#gab983aeeac1801fd1bac9c8074b2c4358"></a><br/></td></tr>
<tr class="memitem:ga90dc951c937e30b96e59f73075bbcd3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga90dc951c937e30b96e59f73075bbcd3a">vfs_find_dirc</a> (char *path)</td></tr>
<tr class="memdesc:ga90dc951c937e30b96e59f73075bbcd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a file referred to by a path.  <a href="#ga90dc951c937e30b96e59f73075bbcd3a"></a><br/></td></tr>
<tr class="memitem:ga2631471cb0ce3ac48ae005747a116bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="permissions_8h.html#a22e726d412d3cf8ca4d1e6c7795c5c0f">perm_class_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga2631471cb0ce3ac48ae005747a116bf9">vfs_get_min_permissions</a> (<a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *<a class="el" href="structinode.html">inode</a>, <a class="el" href="types_8h.html#a161c505f18322d8ce974064784be272a">mode_t</a> req_mode)</td></tr>
<tr class="memdesc:ga2631471cb0ce3ac48ae005747a116bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum privilege level required for access with mode.  <a href="#ga2631471cb0ce3ac48ae005747a116bf9"></a><br/></td></tr>
<tr class="memitem:ga64ad852cc66f2d66221f16ad29c92a04"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga64ad852cc66f2d66221f16ad29c92a04">vfs_have_permissions</a> (<a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *<a class="el" href="structinode.html">inode</a>, <a class="el" href="types_8h.html#a161c505f18322d8ce974064784be272a">mode_t</a> req_mode)</td></tr>
<tr class="memdesc:ga64ad852cc66f2d66221f16ad29c92a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check permissions for access with mode.  <a href="#ga64ad852cc66f2d66221f16ad29c92a04"></a><br/></td></tr>
<tr class="memitem:ga958c0c8e4b441808862e0911fbfc04be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga958c0c8e4b441808862e0911fbfc04be">vfs_get_inode</a> (<a class="el" href="group__vfs.html#ga616bc6ee0262218ac3507c48556a1e6f">fs_device_t</a> *device, <a class="el" href="types_8h.html#ab61b14ba26feb6e4f530bd8ae521e2c9">ino_t</a> inode_id)</td></tr>
<tr class="memdesc:ga958c0c8e4b441808862e0911fbfc04be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an inode by it's ID.  <a href="#ga958c0c8e4b441808862e0911fbfc04be"></a><br/></td></tr>
<tr class="memitem:ga830186f7c888aae883bab689de5a287c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga830186f7c888aae883bab689de5a287c">vfs_effective_inode</a> (<a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *<a class="el" href="structinode.html">inode</a>)</td></tr>
<tr class="memdesc:ga830186f7c888aae883bab689de5a287c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the effective inode for an inode, in other words : Dereference possible symlinks and mounts.  <a href="#ga830186f7c888aae883bab689de5a287c"></a><br/></td></tr>
<tr class="memitem:gac5cf4de9b3b83121a32c4b588117a44d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#gac5cf4de9b3b83121a32c4b588117a44d">vfs_dir_cache_ref</a> (<a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a> *dirc)</td></tr>
<tr class="memdesc:gac5cf4de9b3b83121a32c4b588117a44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new reference to a directory cache entry.  <a href="#gac5cf4de9b3b83121a32c4b588117a44d"></a><br/></td></tr>
<tr class="memitem:gae4a440e3955ca4aa703b3267d7bccae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#gae4a440e3955ca4aa703b3267d7bccae0">vfs_dir_cache_new</a> (<a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a> *par, <a class="el" href="types_8h.html#ab61b14ba26feb6e4f530bd8ae521e2c9">ino_t</a> inode_id)</td></tr>
<tr class="memdesc:gae4a440e3955ca4aa703b3267d7bccae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new directory cache entry.  <a href="#gae4a440e3955ca4aa703b3267d7bccae0"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga2dd256afc91a2d7a99e2082e096664b2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structinode.html">inode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a></td></tr>
<tr class="memdesc:ga2dd256afc91a2d7a99e2082e096664b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a file currently cached by the kernel.  <a href="#ga2dd256afc91a2d7a99e2082e096664b2"></a><br/></td></tr>
<tr class="memitem:ga6673e8f64ca9ebd7e26e6289dca06e87"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structdirent.html">dirent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga6673e8f64ca9ebd7e26e6289dca06e87">dirent_t</a></td></tr>
<tr class="memdesc:ga6673e8f64ca9ebd7e26e6289dca06e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entry in the path element cache.  <a href="#ga6673e8f64ca9ebd7e26e6289dca06e87"></a><br/></td></tr>
<tr class="memitem:gaffb8ec888adfc4b5369e4c175d9903e5"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structdir__cache.html">dir_cache</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a></td></tr>
<tr class="memdesc:gaffb8ec888adfc4b5369e4c175d9903e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">An entry in the path element cache.  <a href="#gaffb8ec888adfc4b5369e4c175d9903e5"></a><br/></td></tr>
<tr class="memitem:ga616bc6ee0262218ac3507c48556a1e6f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfs__device.html">fs_device</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga616bc6ee0262218ac3507c48556a1e6f">fs_device_t</a></td></tr>
<tr class="memdesc:ga616bc6ee0262218ac3507c48556a1e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance of a filesystem driver.  <a href="#ga616bc6ee0262218ac3507c48556a1e6f"></a><br/></td></tr>
<tr class="memitem:ga68b8e1abb7e9c8e49013fb433a657780"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfs__device__operations.html">fs_device_operations</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vfs.html#ga68b8e1abb7e9c8e49013fb433a657780">fs_device_operations_t</a></td></tr>
<tr class="memdesc:ga68b8e1abb7e9c8e49013fb433a657780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains callbacks for all filesystem driver functions.  <a href="#ga68b8e1abb7e9c8e49013fb433a657780"></a><br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<p>The Virtual File System layer provides abstraction between the rest of the kernel and the FS drivers, it handles path resolution, filesystem mounts and all special file types. </p>
<h2>Macro Definition Documentation</h2>
<a class="anchor" id="ga2ab5cedebe651b3858703af1d8301993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODE_EXEC&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit definition for inode-&gt;mode, this file is executable/searchable. </p>

<p>Definition at line <a class="el" href="vfs_8h_source.html#l00050">50</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

<p>Referenced by <a class="el" href="elfloader_8c_source.html#l00025">elf_load()</a>, and <a class="el" href="vfs_8c_source.html#l00295">vfs_find_dirent()</a>.</p>

</div>
</div>
<a class="anchor" id="gac4d1baf108e9ce6414088db508d7c182"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODE_READ&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit definition for inode-&gt;mode, this file is readable. </p>

<p>Definition at line <a class="el" href="vfs_8h_source.html#l00040">40</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

<p>Referenced by <a class="el" href="vfs_8c_source.html#l00932">vfs_getdents()</a>, and <a class="el" href="vfs_8c_source.html#l00760">vfs_read()</a>.</p>

</div>
</div>
<a class="anchor" id="gab8fac4c725bb7d4b05ae138c07ef54af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MODE_WRITE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit definition for inode-&gt;mode, this file is writable. </p>

<p>Definition at line <a class="el" href="vfs_8h_source.html#l00045">45</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

<p>Referenced by <a class="el" href="vfs_8c_source.html#l01950">vfs_link()</a>, <a class="el" href="vfs_8c_source.html#l01296">vfs_mknod()</a>, <a class="el" href="vfs_8c_source.html#l01599">vfs_symlink()</a>, <a class="el" href="vfs_8c_source.html#l01043">vfs_truncate()</a>, <a class="el" href="vfs_8c_source.html#l01789">vfs_unlink()</a>, and <a class="el" href="vfs_8c_source.html#l00553">vfs_write()</a>.</p>

</div>
</div>
<h2>Typedef Documentation</h2>
<a class="anchor" id="gaffb8ec888adfc4b5369e4c175d9903e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structdir__cache.html">dir_cache</a> <a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An entry in the path element cache. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structdir__cache.html" title="An entry in the path element cache The kernel keeps track of these to resolve the ...">dir_cache</a> </dd></dl>

<p>Definition at line <a class="el" href="vfs_8h_source.html#l00068">68</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6673e8f64ca9ebd7e26e6289dca06e87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structdirent.html">dirent</a> <a class="el" href="group__vfs.html#ga6673e8f64ca9ebd7e26e6289dca06e87">dirent_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An entry in the path element cache. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structdirent.html" title="Describes a directory entry in a portable FS independent format.">dirent</a> </dd></dl>

<p>Definition at line <a class="el" href="vfs_8h_source.html#l00062">62</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga68b8e1abb7e9c8e49013fb433a657780"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfs__device__operations.html">fs_device_operations</a> <a class="el" href="group__vfs.html#ga68b8e1abb7e9c8e49013fb433a657780">fs_device_operations_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contains callbacks for all filesystem driver functions. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfs__device__operations.html" title="Contains callbacks for all filesystem driver functions.">fs_device_operations</a> </dd></dl>

<p>Definition at line <a class="el" href="vfs_8h_source.html#l00080">80</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga616bc6ee0262218ac3507c48556a1e6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfs__device.html">fs_device</a> <a class="el" href="group__vfs.html#ga616bc6ee0262218ac3507c48556a1e6f">fs_device_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An instance of a filesystem driver. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfs__device.html" title="An instance of a filesystem driver.">fs_device</a> </dd></dl>

<p>Definition at line <a class="el" href="vfs_8h_source.html#l00074">74</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga2dd256afc91a2d7a99e2082e096664b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structinode.html">inode</a> <a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Describes a file currently cached by the kernel. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structinode.html" title="Describes a file currently cached by the kernel.">inode</a> </dd></dl>

<p>Definition at line <a class="el" href="vfs_8h_source.html#l00056">56</a> of file <a class="el" href="vfs_8h_source.html">vfs.h</a>.</p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="gac950be0dca83a86499018b8c6372b352"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_chdir </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a> *&#160;</td>
          <td class="paramname"><em>dirc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the working directory for this process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirc</td><td>The new working directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or 0 for success </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l02254">2254</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="process_8h_source.html#l00087">process_info::current_directory</a>, <a class="el" href="errno_8h_source.html#l00017">EFAULT</a>, <a class="el" href="errno_8h_source.html#l00023">ENOTDIR</a>, <a class="el" href="vfs_8h_source.html#l00155">dir_cache::inode</a>, <a class="el" href="vfs_8h_source.html#l00105">inode::mode</a>, <a class="el" href="stat_8h_source.html#l00042">S_ISDIR</a>, <a class="el" href="scheduler_8c_source.html#l00023">scheduler_current_task</a>, <a class="el" href="vfs_8c_source.html#l02198">vfs_dir_cache_ref()</a>, and <a class="el" href="vfs_8c_source.html#l02171">vfs_dir_cache_release()</a>.</p>

<p>Referenced by <a class="el" href="sc__vfs_8c_source.html#l00154">_sys_chdir()</a>, and <a class="el" href="streams_8c_source.html#l00321">_sys_fchdir()</a>.</p>

</div>
</div>
<a class="anchor" id="gaaf38fb9429e180341bada6ddd3f3c22a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_chroot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a> *&#160;</td>
          <td class="paramname"><em>dirc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the root directory for this process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirc</td><td>The new root directory </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An error code or 0 for success </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l02278">2278</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="errno_8h_source.html#l00017">EFAULT</a>, <a class="el" href="errno_8h_source.html#l00023">ENOTDIR</a>, <a class="el" href="vfs_8h_source.html#l00155">dir_cache::inode</a>, <a class="el" href="vfs_8h_source.html#l00105">inode::mode</a>, <a class="el" href="process_8h_source.html#l00086">process_info::root_directory</a>, <a class="el" href="stat_8h_source.html#l00042">S_ISDIR</a>, <a class="el" href="scheduler_8c_source.html#l00023">scheduler_current_task</a>, <a class="el" href="vfs_8c_source.html#l02198">vfs_dir_cache_ref()</a>, and <a class="el" href="vfs_8c_source.html#l02171">vfs_dir_cache_release()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9fd0a37c12ffd599dfa7b698180c9a5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a>* vfs_dir_cache_mkroot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td>
          <td class="paramname"><em>root_inode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the initial dir cache entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_inode</td><td>The root inode of the initial root filesystem </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dir cache entry for the root inode </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l02150">2150</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="heapmm_8c_source.html#l00552">heapmm_alloc()</a>, <a class="el" href="vfs_8h_source.html#l00155">dir_cache::inode</a>, <a class="el" href="vfs_8h_source.html#l00153">dir_cache::parent</a>, <a class="el" href="vfs_8h_source.html#l00159">dir_cache::usage_count</a>, and <a class="el" href="vfs_8c_source.html#l00139">vfs_inode_ref()</a>.</p>

<p>Referenced by <a class="el" href="vfs_8c_source.html#l02110">vfs_initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gae4a440e3955ca4aa703b3267d7bccae0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a>* vfs_dir_cache_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a> *&#160;</td>
          <td class="paramname"><em>par</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#ab61b14ba26feb6e4f530bd8ae521e2c9">ino_t</a>&#160;</td>
          <td class="paramname"><em>inode_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new directory cache entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Directory cache entry to use as parent </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new entry </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l02210">2210</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="vfs_8h_source.html#l00094">inode::device</a>, <a class="el" href="heapmm_8c_source.html#l00552">heapmm_alloc()</a>, <a class="el" href="heapmm_8c_source.html#l00574">heapmm_free()</a>, <a class="el" href="vfs_8h_source.html#l00155">dir_cache::inode</a>, <a class="el" href="types_8h_source.html#l00025">NULL</a>, <a class="el" href="vfs_8h_source.html#l00153">dir_cache::parent</a>, <a class="el" href="vfs_8h_source.html#l00159">dir_cache::usage_count</a>, <a class="el" href="vfs_8c_source.html#l02198">vfs_dir_cache_ref()</a>, <a class="el" href="vfs_8c_source.html#l02171">vfs_dir_cache_release()</a>, <a class="el" href="vfs_8c_source.html#l00256">vfs_effective_inode()</a>, <a class="el" href="vfs_8c_source.html#l00215">vfs_get_inode()</a>, and <a class="el" href="vfs_8c_source.html#l00115">vfs_inode_release()</a>.</p>

<p>Referenced by <a class="el" href="vfs_8c_source.html#l02482">vfs_find_dirc()</a>, and <a class="el" href="vfs_8c_source.html#l02305">vfs_find_dirc_parent()</a>.</p>

</div>
</div>
<a class="anchor" id="gac5cf4de9b3b83121a32c4b588117a44d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a>* vfs_dir_cache_ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a> *&#160;</td>
          <td class="paramname"><em>dirc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new reference to a directory cache entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirc</td><td>The entry to refer to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new reference </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l02198">2198</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="vfs_8h_source.html#l00159">dir_cache::usage_count</a>.</p>

<p>Referenced by <a class="el" href="scheduler_8c_source.html#l00066">scheduler_fork()</a>, <a class="el" href="vfs_8c_source.html#l02254">vfs_chdir()</a>, <a class="el" href="vfs_8c_source.html#l02278">vfs_chroot()</a>, <a class="el" href="vfs_8c_source.html#l02210">vfs_dir_cache_new()</a>, <a class="el" href="vfs_8c_source.html#l02482">vfs_find_dirc()</a>, <a class="el" href="vfs_8c_source.html#l02305">vfs_find_dirc_parent()</a>, and <a class="el" href="vfs_8c_source.html#l02110">vfs_initialize()</a>.</p>

</div>
</div>
<a class="anchor" id="gab983aeeac1801fd1bac9c8074b2c4358"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vfs_dir_cache_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a> *&#160;</td>
          <td class="paramname"><em>dirc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a reference to a directory cache entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dirc</td><td>The reference to release </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l02171">2171</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="heapmm_8c_source.html#l00574">heapmm_free()</a>, <a class="el" href="vfs_8h_source.html#l00155">dir_cache::inode</a>, <a class="el" href="vfs_8h_source.html#l00153">dir_cache::parent</a>, <a class="el" href="vfs_8h_source.html#l00159">dir_cache::usage_count</a>, <a class="el" href="vfs_8c_source.html#l02171">vfs_dir_cache_release()</a>, and <a class="el" href="vfs_8c_source.html#l00115">vfs_inode_release()</a>.</p>

<p>Referenced by <a class="el" href="process_8c_source.html#l00193">process_reap()</a>, <a class="el" href="vfs_8c_source.html#l02254">vfs_chdir()</a>, <a class="el" href="vfs_8c_source.html#l02278">vfs_chroot()</a>, <a class="el" href="vfs_8c_source.html#l02210">vfs_dir_cache_new()</a>, <a class="el" href="vfs_8c_source.html#l02171">vfs_dir_cache_release()</a>, <a class="el" href="vfs_8c_source.html#l02482">vfs_find_dirc()</a>, <a class="el" href="vfs_8c_source.html#l02305">vfs_find_dirc_parent()</a>, <a class="el" href="vfs_8c_source.html#l02680">vfs_find_inode()</a>, <a class="el" href="vfs_8c_source.html#l02653">vfs_find_parent()</a>, and <a class="el" href="vfs_8c_source.html#l02708">vfs_find_symlink()</a>.</p>

</div>
</div>
<a class="anchor" id="ga830186f7c888aae883bab689de5a287c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a>* vfs_effective_inode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td>
          <td class="paramname"><em>inode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the effective inode for an inode, in other words : Dereference possible symlinks and mounts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>The inode that is to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inode that the parameter points to. </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l00256">256</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="vfs_8h_source.html#l00110">inode::link_path</a>, <a class="el" href="vfs_8h_source.html#l00114">inode::mount</a>, <a class="el" href="types_8h_source.html#l00025">NULL</a>, <a class="el" href="vfs_8c_source.html#l02680">vfs_find_inode()</a>, and <a class="el" href="vfs_8c_source.html#l00139">vfs_inode_ref()</a>.</p>

<p>Referenced by <a class="el" href="vfs_8c_source.html#l02210">vfs_dir_cache_new()</a>, <a class="el" href="vfs_8c_source.html#l00932">vfs_getdents()</a>, <a class="el" href="vfs_8c_source.html#l00760">vfs_read()</a>, <a class="el" href="vfs_8c_source.html#l01043">vfs_truncate()</a>, and <a class="el" href="vfs_8c_source.html#l00553">vfs_write()</a>.</p>

</div>
</div>
<a class="anchor" id="ga90dc951c937e30b96e59f73075bbcd3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__vfs.html#gaffb8ec888adfc4b5369e4c175d9903e5">dir_cache_t</a>* vfs_find_dirc </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up a file referred to by a path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to resolve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structdir__cache.html" title="An entry in the path element cache The kernel keeps track of these to resolve the ...">dir_cache</a> entry on the file referred to by path </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000090">Todo:</a></b></dt><dd>: Check for errors </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l02482">2482</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="config_8h_source.html#l00010">CONFIG_FILE_MAX_NAME_LENGTH</a>, <a class="el" href="process_8h_source.html#l00087">process_info::current_directory</a>, <a class="el" href="heapmm_8c_source.html#l00552">heapmm_alloc()</a>, <a class="el" href="heapmm_8c_source.html#l00574">heapmm_free()</a>, <a class="el" href="vfs_8h_source.html#l00155">dir_cache::inode</a>, <a class="el" href="vfs_8h_source.html#l00134">dirent::inode_id</a>, <a class="el" href="vfs_8h_source.html#l00105">inode::mode</a>, <a class="el" href="types_8h_source.html#l00025">NULL</a>, <a class="el" href="vfs_8h_source.html#l00153">dir_cache::parent</a>, <a class="el" href="process_8h_source.html#l00086">process_info::root_directory</a>, <a class="el" href="stat_8h_source.html#l00042">S_ISDIR</a>, <a class="el" href="scheduler_8c_source.html#l00023">scheduler_current_task</a>, <a class="el" href="string_8c_source.html#l00004">strchr()</a>, <a class="el" href="string_8c_source.html#l00029">strchrnul()</a>, <a class="el" href="string_8c_source.html#l00102">strncmp()</a>, <a class="el" href="string_8c_source.html#l00070">strncpy()</a>, <a class="el" href="vfs_8h_source.html#l00159">dir_cache::usage_count</a>, <a class="el" href="vfs_8c_source.html#l02210">vfs_dir_cache_new()</a>, <a class="el" href="vfs_8c_source.html#l02198">vfs_dir_cache_ref()</a>, <a class="el" href="vfs_8c_source.html#l02171">vfs_dir_cache_release()</a>, and <a class="el" href="vfs_8c_source.html#l00295">vfs_find_dirent()</a>.</p>

<p>Referenced by <a class="el" href="sc__vfs_8c_source.html#l00154">_sys_chdir()</a>, <a class="el" href="streams_8c_source.html#l00585">_sys_open()</a>, <a class="el" href="vfs_8c_source.html#l02680">vfs_find_inode()</a>, and <a class="el" href="vfs_8c_source.html#l02708">vfs_find_symlink()</a>.</p>

</div>
</div>
<a class="anchor" id="ga489abb04eb8e74a3f11a0a20f32a845c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__vfs.html#ga6673e8f64ca9ebd7e26e6289dca06e87">dirent_t</a>* vfs_find_dirent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a directory entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>The directory to search </td></tr>
    <tr><td class="paramname">name</td><td>The filename to match </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The directory entry matching name from the directory inode, if none, NULL is returned </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000082">Todo:</a></b></dt><dd>: Find a way to pass an error from here </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l00295">295</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="vfs_8h_source.html#l00094">inode::device</a>, <a class="el" href="vfs_8h_source.html#l00288">fs_device_operations::find_dirent</a>, <a class="el" href="vfs_8h_source.html#l00050">MODE_EXEC</a>, <a class="el" href="types_8h_source.html#l00025">NULL</a>, <a class="el" href="vfs_8h_source.html#l00367">fs_device::ops</a>, and <a class="el" href="vfs_8c_source.html#l00203">vfs_have_permissions()</a>.</p>

<p>Referenced by <a class="el" href="vfs_8c_source.html#l02482">vfs_find_dirc()</a>, <a class="el" href="vfs_8c_source.html#l02305">vfs_find_dirc_parent()</a>, and <a class="el" href="vfs_8c_source.html#l02708">vfs_find_symlink()</a>.</p>

</div>
</div>
<a class="anchor" id="ga60e197d9a65de9d15c88f8fa1f6e7c97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a>* vfs_find_inode </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the inode for the file referenced by path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the file to resolve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file's inode </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l02680">2680</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="vfs_8h_source.html#l00155">dir_cache::inode</a>, <a class="el" href="types_8h_source.html#l00025">NULL</a>, <a class="el" href="vfs_8c_source.html#l02171">vfs_dir_cache_release()</a>, <a class="el" href="vfs_8c_source.html#l02482">vfs_find_dirc()</a>, and <a class="el" href="vfs_8c_source.html#l00139">vfs_inode_ref()</a>.</p>

<p>Referenced by <a class="el" href="sc__vfs_8c_source.html#l00193">_sys_chmod()</a>, <a class="el" href="sc__vfs_8c_source.html#l00233">_sys_chown()</a>, <a class="el" href="sc__vfs_8c_source.html#l00363">_sys_stat()</a>, <a class="el" href="sc__vfs_8c_source.html#l00275">_sys_truncate()</a>, <a class="el" href="elfloader_8c_source.html#l00025">elf_load()</a>, <a class="el" href="tar_8c_source.html#l00026">tar_extract()</a>, <a class="el" href="tar_8c_source.html#l00196">tar_read_record()</a>, <a class="el" href="tar_8c_source.html#l00104">tar_read_record_mem()</a>, <a class="el" href="vfs_8c_source.html#l00256">vfs_effective_inode()</a>, <a class="el" href="vfs_8c_source.html#l01950">vfs_link()</a>, <a class="el" href="vfs_8c_source.html#l01201">vfs_mkdir()</a>, <a class="el" href="vfs_8c_source.html#l01296">vfs_mknod()</a>, <a class="el" href="vfs_8c_source.html#l01489">vfs_mount()</a>, <a class="el" href="vfs_8c_source.html#l01142">vfs_rmdir()</a>, and <a class="el" href="vfs_8c_source.html#l01599">vfs_symlink()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa8336c694b79fb0e56847ab2e1b26750"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a>* vfs_find_parent </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the inode for the directory containing the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the file to resolve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file's parent directory </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000091">Todo:</a></b></dt><dd>: Check for search permission </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l02653">2653</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="vfs_8h_source.html#l00155">dir_cache::inode</a>, <a class="el" href="types_8h_source.html#l00025">NULL</a>, <a class="el" href="vfs_8c_source.html#l02171">vfs_dir_cache_release()</a>, <a class="el" href="vfs_8c_source.html#l02305">vfs_find_dirc_parent()</a>, and <a class="el" href="vfs_8c_source.html#l00139">vfs_inode_ref()</a>.</p>

<p>Referenced by <a class="el" href="vfs_8c_source.html#l01950">vfs_link()</a>, <a class="el" href="vfs_8c_source.html#l01201">vfs_mkdir()</a>, <a class="el" href="vfs_8c_source.html#l01296">vfs_mknod()</a>, <a class="el" href="vfs_8c_source.html#l01599">vfs_symlink()</a>, and <a class="el" href="vfs_8c_source.html#l01789">vfs_unlink()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5b390b5f69c09ba25d6ecec740c301d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a>* vfs_find_symlink </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up the inode for the file referenced by path, not dereferencing symlinks or mounts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the file to resolve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file's inode </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l02708">2708</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="process_8h_source.html#l00087">process_info::current_directory</a>, <a class="el" href="vfs_8h_source.html#l00094">inode::device</a>, <a class="el" href="heapmm_8c_source.html#l00574">heapmm_free()</a>, <a class="el" href="vfs_8h_source.html#l00155">dir_cache::inode</a>, <a class="el" href="vfs_8h_source.html#l00134">dirent::inode_id</a>, <a class="el" href="types_8h_source.html#l00025">NULL</a>, <a class="el" href="vfs_8h_source.html#l00153">dir_cache::parent</a>, <a class="el" href="process_8h_source.html#l00086">process_info::root_directory</a>, <a class="el" href="scheduler_8c_source.html#l00023">scheduler_current_task</a>, <a class="el" href="string_8c_source.html#l00038">strlen()</a>, <a class="el" href="vfs_8c_source.html#l02171">vfs_dir_cache_release()</a>, <a class="el" href="vfs_8c_source.html#l02482">vfs_find_dirc()</a>, <a class="el" href="vfs_8c_source.html#l00295">vfs_find_dirent()</a>, <a class="el" href="vfs_8c_source.html#l00053">vfs_get_filename()</a>, <a class="el" href="vfs_8c_source.html#l00215">vfs_get_inode()</a>, and <a class="el" href="vfs_8c_source.html#l00139">vfs_inode_ref()</a>.</p>

<p>Referenced by <a class="el" href="sc__vfs_8c_source.html#l00474">_sys_lstat()</a>, <a class="el" href="sc__vfs_8c_source.html#l00419">_sys_readlink()</a>, and <a class="el" href="vfs_8c_source.html#l01789">vfs_unlink()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf09508470980cccac2b4a2b86cd0c716"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* vfs_get_filename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the filename part of a path. </p>
<dl class="section warning"><dt>Warning</dt><dd>This allocates heap for the return value, free with heapmm_free(r, strlen(r) + 1); </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to analyze </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The file name, see warning! </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000081">Todo:</a></b></dt><dd>: Come up with a way to do this without tripping heap alloc error </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l00053">53</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="heapmm_8c_source.html#l00552">heapmm_alloc()</a>, <a class="el" href="heapmm_8c_source.html#l00574">heapmm_free()</a>, <a class="el" href="types_8h_source.html#l00025">NULL</a>, <a class="el" href="string_8c_source.html#l00065">strcpy()</a>, <a class="el" href="string_8c_source.html#l00038">strlen()</a>, and <a class="el" href="string_8c_source.html#l00017">strrchr()</a>.</p>

<p>Referenced by <a class="el" href="elfloader_8c_source.html#l00025">elf_load()</a>, <a class="el" href="vfs_8c_source.html#l02708">vfs_find_symlink()</a>, <a class="el" href="vfs_8c_source.html#l01950">vfs_link()</a>, <a class="el" href="vfs_8c_source.html#l01296">vfs_mknod()</a>, <a class="el" href="vfs_8c_source.html#l01599">vfs_symlink()</a>, and <a class="el" href="vfs_8c_source.html#l01789">vfs_unlink()</a>.</p>

</div>
</div>
<a class="anchor" id="ga958c0c8e4b441808862e0911fbfc04be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a>* vfs_get_inode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#ga616bc6ee0262218ac3507c48556a1e6f">fs_device_t</a> *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#ab61b14ba26feb6e4f530bd8ae521e2c9">ino_t</a>&#160;</td>
          <td class="paramname"><em>inode_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an inode by it's ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to get the inode from </td></tr>
    <tr><td class="paramname">inode_id</td><td>The ID of the inode to look up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inode with id inode_id from device. </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l00215">215</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="vfs_8c_source.html#l00041">vfs_cache_params::device_id</a>, <a class="el" href="vfs_8h_source.html#l00363">fs_device::id</a>, <a class="el" href="vfs_8c_source.html#l00042">vfs_cache_params::inode_id</a>, <a class="el" href="llist_8c_source.html#l00141">llist_iterate_select()</a>, <a class="el" href="vfs_8h_source.html#l00183">fs_device_operations::load_inode</a>, <a class="el" href="vfs_8h_source.html#l00367">fs_device::ops</a>, <a class="el" href="vfs_8c_source.html#l00166">vfs_cache_find_iterator()</a>, and <a class="el" href="vfs_8c_source.html#l00139">vfs_inode_ref()</a>.</p>

<p>Referenced by <a class="el" href="vfs_8c_source.html#l02210">vfs_dir_cache_new()</a>, and <a class="el" href="vfs_8c_source.html#l02708">vfs_find_symlink()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2631471cb0ce3ac48ae005747a116bf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="permissions_8h.html#a22e726d412d3cf8ca4d1e6c7795c5c0f">perm_class_t</a> vfs_get_min_permissions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a161c505f18322d8ce974064784be272a">mode_t</a>&#160;</td>
          <td class="paramname"><em>req_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the minimum privilege level required for access with mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>The file to check </td></tr>
    <tr><td class="paramname">req_mode</td><td>The requested access mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The required privilege class : other, group or owner </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l00185">185</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="vfs_8h_source.html#l00105">inode::mode</a>, <a class="el" href="permissions_8h_source.html#l00020">PERM_CLASS_GROUP</a>, <a class="el" href="permissions_8h_source.html#l00018">PERM_CLASS_NONE</a>, <a class="el" href="permissions_8h_source.html#l00021">PERM_CLASS_OTHER</a>, and <a class="el" href="permissions_8h_source.html#l00019">PERM_CLASS_OWNER</a>.</p>

<p>Referenced by <a class="el" href="vfs_8c_source.html#l00203">vfs_have_permissions()</a>.</p>

</div>
</div>
<a class="anchor" id="ga94b66b2d752c243c35894d6655626566"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_getdents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td>
          <td class="paramname"><em>_inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a>&#160;</td>
          <td class="paramname"><em>file_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__vfs.html#ga6673e8f64ca9ebd7e26e6289dca06e87">dirent_t</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a> *&#160;</td>
          <td class="paramname"><em>read_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read directory entries. </p>
<p>This function will only read whole directory entries, if a directory entry does not fit in count it will return only the amount of bytes read before that entry</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_inode</td><td>The inode for the directory </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to store the entries in </td></tr>
    <tr><td class="paramname">file_offset</td><td>The offset in the directory to start reading at </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to read </td></tr>
    <tr><td class="paramname">read_size</td><td>A pointer to a variable in which the number of bytes read will be stored</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In case of error: a valid error code, Otherwise 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EFAULT</td><td>Atleast one parameter was a NULL pointer </td></tr>
    <tr><td class="paramname">EBADF</td><td>Tried to read from a directory for which we do not have permission </td></tr>
    <tr><td class="paramname">ENOTDIR</td><td>Can only read directory entries from a directory </td></tr>
    <tr><td class="paramname">EIO</td><td>An IO error was encountered trying to read from the dir </td></tr>
    <tr><td class="paramname">ENOMEM</td><td>Could not allocate kernel heap for a temporary structure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l00932">932</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="vfs_8h_source.html#l00122">inode::atime</a>, <a class="el" href="errno_8h_source.html#l00012">EBADF</a>, <a class="el" href="errno_8h_source.html#l00017">EFAULT</a>, <a class="el" href="errno_8h_source.html#l00023">ENOTDIR</a>, <a class="el" href="vfs_8h_source.html#l00116">inode::lock</a>, <a class="el" href="vfs_8h_source.html#l00105">inode::mode</a>, <a class="el" href="vfs_8h_source.html#l00040">MODE_READ</a>, <a class="el" href="stat_8h_source.html#l00028">S_IFDIR</a>, <a class="el" href="stat_8h_source.html#l00020">S_IFMT</a>, <a class="el" href="synch_8c_source.html#l00029">semaphore_down()</a>, <a class="el" href="synch_8c_source.html#l00023">semaphore_up()</a>, <a class="el" href="vfs_8h_source.html#l00120">inode::size</a>, <a class="el" href="time_8c_source.html#l00025">system_time</a>, <a class="el" href="vfs_8c_source.html#l00256">vfs_effective_inode()</a>, <a class="el" href="vfs_8c_source.html#l00203">vfs_have_permissions()</a>, <a class="el" href="vfs_8c_source.html#l00115">vfs_inode_release()</a>, and <a class="el" href="vfs_8c_source.html#l00439">vfs_int_read_dir()</a>.</p>

<p>Referenced by <a class="el" href="streams_8c_source.html#l00098">_sys_getdents()</a>.</p>

</div>
</div>
<a class="anchor" id="ga64ad852cc66f2d66221f16ad29c92a04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_have_permissions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td>
          <td class="paramname"><em>inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a161c505f18322d8ce974064784be272a">mode_t</a>&#160;</td>
          <td class="paramname"><em>req_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check permissions for access with mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>The file to check </td></tr>
    <tr><td class="paramname">req_mode</td><td>The requested access mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the requested access is allowed </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l00203">203</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="permissions_8c_source.html#l00035">get_perm_class()</a>, <a class="el" href="vfs_8h_source.html#l00103">inode::gid</a>, <a class="el" href="vfs_8h_source.html#l00101">inode::uid</a>, and <a class="el" href="vfs_8c_source.html#l00185">vfs_get_min_permissions()</a>.</p>

<p>Referenced by <a class="el" href="elfloader_8c_source.html#l00025">elf_load()</a>, <a class="el" href="vfs_8c_source.html#l00295">vfs_find_dirent()</a>, <a class="el" href="vfs_8c_source.html#l00932">vfs_getdents()</a>, <a class="el" href="vfs_8c_source.html#l01950">vfs_link()</a>, <a class="el" href="vfs_8c_source.html#l01296">vfs_mknod()</a>, <a class="el" href="vfs_8c_source.html#l00760">vfs_read()</a>, <a class="el" href="vfs_8c_source.html#l01599">vfs_symlink()</a>, <a class="el" href="vfs_8c_source.html#l01043">vfs_truncate()</a>, <a class="el" href="vfs_8c_source.html#l01789">vfs_unlink()</a>, and <a class="el" href="vfs_8c_source.html#l00553">vfs_write()</a>.</p>

</div>
</div>
<a class="anchor" id="gac1913485037320335c4030439d537df8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#ga616bc6ee0262218ac3507c48556a1e6f">fs_device_t</a> *&#160;</td>
          <td class="paramname"><em>root_device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the VFS layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_device</td><td>The filesystem device to use as root filesystem </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful 1, otherwise 0 </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000088">Todo:</a></b></dt><dd>: Track mounted devices </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l02110">2110</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="process_8h_source.html#l00087">process_info::current_directory</a>, <a class="el" href="heapmm_8c_source.html#l00552">heapmm_alloc()</a>, <a class="el" href="llist_8c_source.html#l00078">llist_add_end()</a>, <a class="el" href="llist_8c_source.html#l00107">llist_create()</a>, <a class="el" href="vfs_8h_source.html#l00183">fs_device_operations::load_inode</a>, <a class="el" href="vfs_8h_source.html#l00367">fs_device::ops</a>, <a class="el" href="process_8h_source.html#l00086">process_info::root_directory</a>, <a class="el" href="vfs_8h_source.html#l00365">fs_device::root_inode_id</a>, <a class="el" href="scheduler_8c_source.html#l00023">scheduler_current_task</a>, <a class="el" href="vfs_8c_source.html#l02150">vfs_dir_cache_mkroot()</a>, and <a class="el" href="vfs_8c_source.html#l02198">vfs_dir_cache_ref()</a>.</p>

<p>Referenced by <a class="el" href="init_8c_source.html#l00246">i386_kmain()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3494d0da607504093448c9fbc5d2623e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vfs_inode_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td>
          <td class="paramname"><em>inode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release a reference to an inode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inode</td><td>The reference to release </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l00115">115</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="llist_8c_source.html#l00078">llist_add_end()</a>, <a class="el" href="llist_8c_source.html#l00093">llist_unlink()</a>, <a class="el" href="vfs_8h_source.html#l00114">inode::mount</a>, and <a class="el" href="vfs_8h_source.html#l00118">inode::usage_count</a>.</p>

<p>Referenced by <a class="el" href="elfloader_8c_source.html#l00025">elf_load()</a>, <a class="el" href="vfs_8c_source.html#l02210">vfs_dir_cache_new()</a>, <a class="el" href="vfs_8c_source.html#l02171">vfs_dir_cache_release()</a>, <a class="el" href="vfs_8c_source.html#l00932">vfs_getdents()</a>, <a class="el" href="vfs_8c_source.html#l01950">vfs_link()</a>, <a class="el" href="vfs_8c_source.html#l01201">vfs_mkdir()</a>, <a class="el" href="vfs_8c_source.html#l01296">vfs_mknod()</a>, <a class="el" href="vfs_8c_source.html#l01489">vfs_mount()</a>, <a class="el" href="vfs_8c_source.html#l00760">vfs_read()</a>, <a class="el" href="vfs_8c_source.html#l01142">vfs_rmdir()</a>, <a class="el" href="vfs_8c_source.html#l01599">vfs_symlink()</a>, <a class="el" href="vfs_8c_source.html#l01043">vfs_truncate()</a>, <a class="el" href="vfs_8c_source.html#l01789">vfs_unlink()</a>, and <a class="el" href="vfs_8c_source.html#l00553">vfs_write()</a>.</p>

</div>
</div>
<a class="anchor" id="gac8b32bb45661974629d18b9830c5d026"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_link </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>oldpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>newpath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a hard link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldpath</td><td>The target of the link </td></tr>
    <tr><td class="paramname">newpath</td><td>The path of the link </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In case of error: a valid error code, Otherwise 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EFAULT</td><td>Atleast one parameter was a NULL pointer </td></tr>
    <tr><td class="paramname">ENOENT</td><td>The parent directory or target does not exist </td></tr>
    <tr><td class="paramname">EEXIST</td><td>A file already exists at the given path </td></tr>
    <tr><td class="paramname">EIO</td><td>An IO error occurred while creating the link </td></tr>
    <tr><td class="paramname">EACCES</td><td>User does not have write permission for the parent dir </td></tr>
    <tr><td class="paramname">ENOSPC</td><td>Not enough disk space was available </td></tr>
    <tr><td class="paramname">ENOMEM</td><td>Could not allocate kernel heap for a temporary structure </td></tr>
    <tr><td class="paramname">EXDEV</td><td>Tried to create a cross-device link </td></tr>
    <tr><td class="paramname">ENAMETOOLONG</td><td>The name of the file is longer than the maximum allowed number of characters for a file name </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l01950">1950</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="config_8h_source.html#l00010">CONFIG_FILE_MAX_NAME_LENGTH</a>, <a class="el" href="vfs_8h_source.html#l00126">inode::ctime</a>, <a class="el" href="vfs_8h_source.html#l00092">inode::device_id</a>, <a class="el" href="errno_8h_source.html#l00016">EACCES</a>, <a class="el" href="errno_8h_source.html#l00020">EEXIST</a>, <a class="el" href="errno_8h_source.html#l00017">EFAULT</a>, <a class="el" href="errno_8h_source.html#l00085">ENAMETOOLONG</a>, <a class="el" href="errno_8h_source.html#l00005">ENOENT</a>, <a class="el" href="errno_8h_source.html#l00021">EXDEV</a>, <a class="el" href="vfs_8h_source.html#l00098">inode::hard_link_count</a>, <a class="el" href="heapmm_8c_source.html#l00574">heapmm_free()</a>, <a class="el" href="vfs_8h_source.html#l00090">inode::id</a>, <a class="el" href="vfs_8h_source.html#l00116">inode::lock</a>, <a class="el" href="vfs_8h_source.html#l00045">MODE_WRITE</a>, <a class="el" href="vfs_8h_source.html#l00124">inode::mtime</a>, <a class="el" href="synch_8c_source.html#l00029">semaphore_down()</a>, <a class="el" href="synch_8c_source.html#l00023">semaphore_up()</a>, <a class="el" href="string_8c_source.html#l00038">strlen()</a>, <a class="el" href="time_8c_source.html#l00025">system_time</a>, <a class="el" href="vfs_8c_source.html#l02680">vfs_find_inode()</a>, <a class="el" href="vfs_8c_source.html#l02653">vfs_find_parent()</a>, <a class="el" href="vfs_8c_source.html#l00053">vfs_get_filename()</a>, <a class="el" href="vfs_8c_source.html#l00203">vfs_have_permissions()</a>, <a class="el" href="vfs_8c_source.html#l00115">vfs_inode_release()</a>, and <a class="el" href="vfs_8c_source.html#l00389">vfs_int_link()</a>.</p>

<p>Referenced by <a class="el" href="sc__vfs_8c_source.html#l00023">sys_link()</a>, <a class="el" href="tar_8c_source.html#l00196">tar_read_record()</a>, and <a class="el" href="tar_8c_source.html#l00104">tar_read_record_mem()</a>.</p>

</div>
</div>
<a class="anchor" id="ga22ee4ff0cc661e9246bd6a76702b298e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_mkdir </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a161c505f18322d8ce974064784be272a">mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the directory to create </td></tr>
    <tr><td class="paramname">mode</td><td>The mode of the directory to create, only access modes are used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In case of error: a valid error code, Otherwise 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EFAULT</td><td>Atleast one parameter was a NULL pointer </td></tr>
    <tr><td class="paramname">ENOENT</td><td>The parent directory does not exist </td></tr>
    <tr><td class="paramname">EEXIST</td><td>A file already exists at the given path </td></tr>
    <tr><td class="paramname">EIO</td><td>An IO error occurred while creating the directory </td></tr>
    <tr><td class="paramname">EACCES</td><td>User does not have write permission for the parent dir </td></tr>
    <tr><td class="paramname">ENOSPC</td><td>Not enough disk space was available </td></tr>
    <tr><td class="paramname">ENOMEM</td><td>Could not allocate kernel heap for a temporary structure </td></tr>
    <tr><td class="paramname">ENAMETOOLONG</td><td>The name of the file is longer than the maximum allowed number of characters for a file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000084">Todo:</a></b></dt><dd>: Make this an assertion </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000085">Todo:</a></b></dt><dd>: Make this an assertion </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l01201">1201</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="errno_8h_source.html#l00017">EFAULT</a>, <a class="el" href="vfs_8h_source.html#l00116">inode::lock</a>, <a class="el" href="vfs_8h_source.html#l00124">inode::mtime</a>, <a class="el" href="stat_8h_source.html#l00028">S_IFDIR</a>, <a class="el" href="synch_8c_source.html#l00029">semaphore_down()</a>, <a class="el" href="synch_8c_source.html#l00023">semaphore_up()</a>, <a class="el" href="time_8c_source.html#l00025">system_time</a>, <a class="el" href="vfs_8c_source.html#l02680">vfs_find_inode()</a>, <a class="el" href="vfs_8c_source.html#l02653">vfs_find_parent()</a>, <a class="el" href="vfs_8c_source.html#l00115">vfs_inode_release()</a>, <a class="el" href="vfs_8c_source.html#l00365">vfs_int_mkdir()</a>, <a class="el" href="vfs_8c_source.html#l01296">vfs_mknod()</a>, and <a class="el" href="vfs_8c_source.html#l01789">vfs_unlink()</a>.</p>

<p>Referenced by <a class="el" href="sc__vfs_8c_source.html#l00340">sys_mkdir()</a>, <a class="el" href="tar_8c_source.html#l00196">tar_read_record()</a>, and <a class="el" href="tar_8c_source.html#l00104">tar_read_record_mem()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1833cb4e7ef568776472b7d940eccf04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_mknod </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a161c505f18322d8ce974064784be272a">mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a31acaaf3092d869de3b5e34d11695520">dev_t</a>&#160;</td>
          <td class="paramname"><em>dev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the file to create </td></tr>
    <tr><td class="paramname">mode</td><td>The mode of the file to create </td></tr>
    <tr><td class="paramname">dev</td><td>The device id to use in case of a special file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In case of error: a valid error code, Otherwise 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EFAULT</td><td>Atleast one parameter was a NULL pointer </td></tr>
    <tr><td class="paramname">ENOENT</td><td>The parent directory does not exist </td></tr>
    <tr><td class="paramname">EEXIST</td><td>A file already exists at the given path </td></tr>
    <tr><td class="paramname">EIO</td><td>An IO error occurred while creating the file </td></tr>
    <tr><td class="paramname">EACCES</td><td>User does not have write permission for the parent dir </td></tr>
    <tr><td class="paramname">ENOSPC</td><td>Not enough disk space was available </td></tr>
    <tr><td class="paramname">ENOMEM</td><td>Could not allocate kernel heap for a temporary structure </td></tr>
    <tr><td class="paramname">ENAMETOOLONG</td><td>The name of the file is longer than the maximum allowed number of characters for a file name </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l01296">1296</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="vfs_8h_source.html#l00122">inode::atime</a>, <a class="el" href="config_8h_source.html#l00010">CONFIG_FILE_MAX_NAME_LENGTH</a>, <a class="el" href="vfs_8h_source.html#l00126">inode::ctime</a>, <a class="el" href="vfs_8h_source.html#l00094">inode::device</a>, <a class="el" href="vfs_8h_source.html#l00092">inode::device_id</a>, <a class="el" href="errno_8h_source.html#l00016">EACCES</a>, <a class="el" href="errno_8h_source.html#l00020">EEXIST</a>, <a class="el" href="errno_8h_source.html#l00017">EFAULT</a>, <a class="el" href="errno_8h_source.html#l00085">ENAMETOOLONG</a>, <a class="el" href="errno_8h_source.html#l00005">ENOENT</a>, <a class="el" href="errno_8h_source.html#l00015">ENOMEM</a>, <a class="el" href="vfs_8h_source.html#l00112">inode::fifo</a>, <a class="el" href="process_8h_source.html#l00076">process_info::gid</a>, <a class="el" href="vfs_8h_source.html#l00103">inode::gid</a>, <a class="el" href="vfs_8h_source.html#l00098">inode::hard_link_count</a>, <a class="el" href="heapmm_8c_source.html#l00552">heapmm_alloc()</a>, <a class="el" href="heapmm_8c_source.html#l00574">heapmm_free()</a>, <a class="el" href="vfs_8h_source.html#l00090">inode::id</a>, <a class="el" href="vfs_8h_source.html#l00108">inode::if_dev</a>, <a class="el" href="vfs_8h_source.html#l00375">fs_device::inode_size</a>, <a class="el" href="llist_8c_source.html#l00093">llist_unlink()</a>, <a class="el" href="vfs_8h_source.html#l00116">inode::lock</a>, <a class="el" href="string_8c_source.html#l00045">memset()</a>, <a class="el" href="vfs_8h_source.html#l00105">inode::mode</a>, <a class="el" href="vfs_8h_source.html#l00045">MODE_WRITE</a>, <a class="el" href="vfs_8h_source.html#l00124">inode::mtime</a>, <a class="el" href="vfs_8h_source.html#l00096">inode::name</a>, <a class="el" href="pipe_8c_source.html#l00022">pipe_create()</a>, <a class="el" href="stat_8h_source.html#l00045">S_ISFIFO</a>, <a class="el" href="scheduler_8c_source.html#l00023">scheduler_current_task</a>, <a class="el" href="synch_8c_source.html#l00068">semaphore_alloc()</a>, <a class="el" href="synch_8c_source.html#l00029">semaphore_down()</a>, <a class="el" href="synch_8c_source.html#l00023">semaphore_up()</a>, <a class="el" href="string_8c_source.html#l00065">strcpy()</a>, <a class="el" href="string_8c_source.html#l00038">strlen()</a>, <a class="el" href="time_8c_source.html#l00025">system_time</a>, <a class="el" href="process_8h_source.html#l00075">process_info::uid</a>, <a class="el" href="vfs_8h_source.html#l00101">inode::uid</a>, <a class="el" href="process_8h_source.html#l00088">process_info::umask</a>, <a class="el" href="vfs_8c_source.html#l02680">vfs_find_inode()</a>, <a class="el" href="vfs_8c_source.html#l02653">vfs_find_parent()</a>, <a class="el" href="vfs_8c_source.html#l00053">vfs_get_filename()</a>, <a class="el" href="vfs_8c_source.html#l00203">vfs_have_permissions()</a>, <a class="el" href="vfs_8c_source.html#l00157">vfs_inode_cache()</a>, <a class="el" href="vfs_8c_source.html#l00115">vfs_inode_release()</a>, <a class="el" href="vfs_8c_source.html#l00389">vfs_int_link()</a>, <a class="el" href="vfs_8c_source.html#l00321">vfs_int_mknod()</a>, and <a class="el" href="vfs_8c_source.html#l00343">vfs_int_rmnod()</a>.</p>

<p>Referenced by <a class="el" href="streams_8c_source.html#l00585">_sys_open()</a>, <a class="el" href="init_8c_source.html#l00246">i386_kmain()</a>, <a class="el" href="sc__vfs_8c_source.html#l00316">sys_mknod()</a>, <a class="el" href="tar_8c_source.html#l00196">tar_read_record()</a>, <a class="el" href="tar_8c_source.html#l00104">tar_read_record_mem()</a>, and <a class="el" href="vfs_8c_source.html#l01201">vfs_mkdir()</a>.</p>

</div>
</div>
<a class="anchor" id="ga61886b169216dc8c85945584536fbb1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_mount </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>mountpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>fstype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mount a filesystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The path of the block special file the fs resides on </td></tr>
    <tr><td class="paramname">mountpoint</td><td>The directory to mount the fs on </td></tr>
    <tr><td class="paramname">fstype</td><td>The filesystem driver to use e.g.: ext2, ramfs </td></tr>
    <tr><td class="paramname">flags</td><td>Options for mounting the fs that are passed to the fs driver </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In case of error: a valid error code, Otherwise 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EFAULT</td><td>Atleast one parameter was a NULL pointer </td></tr>
    <tr><td class="paramname">ENOENT</td><td>A file does not exist </td></tr>
    <tr><td class="paramname">EINVAL</td><td>An error occurred mounting the filesystem </td></tr>
    <tr><td class="paramname">ENOTDIR</td><td>The mount point is not a directory </td></tr>
    <tr><td class="paramname">ENOTBLK</td><td>The special file is not a block special file </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000086">Todo:</a></b></dt><dd>: Support multiple filesystems </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000087">Todo:</a></b></dt><dd>: Unmount </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l01489">1489</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="errno_8h_source.html#l00017">EFAULT</a>, <a class="el" href="errno_8h_source.html#l00025">EINVAL</a>, <a class="el" href="errno_8h_source.html#l00005">ENOENT</a>, <a class="el" href="errno_8h_source.html#l00018">ENOTBLK</a>, <a class="el" href="errno_8h_source.html#l00023">ENOTDIR</a>, <a class="el" href="ext2_8c_source.html#l00474">ext2_mount()</a>, <a class="el" href="vfs_8h_source.html#l00108">inode::if_dev</a>, <a class="el" href="vfs_8h_source.html#l00183">fs_device_operations::load_inode</a>, <a class="el" href="vfs_8h_source.html#l00105">inode::mode</a>, <a class="el" href="vfs_8h_source.html#l00114">inode::mount</a>, <a class="el" href="vfs_8h_source.html#l00367">fs_device::ops</a>, <a class="el" href="vfs_8h_source.html#l00365">fs_device::root_inode_id</a>, <a class="el" href="stat_8h_source.html#l00044">S_ISBLK</a>, <a class="el" href="stat_8h_source.html#l00042">S_ISDIR</a>, <a class="el" href="vfs_8c_source.html#l02680">vfs_find_inode()</a>, and <a class="el" href="vfs_8c_source.html#l00115">vfs_inode_release()</a>.</p>

<p>Referenced by <a class="el" href="sc__vfs_8c_source.html#l00055">sys_mount()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b462cea173d8cd38ab8b46b98a159d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td>
          <td class="paramname"><em>_inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a>&#160;</td>
          <td class="paramname"><em>file_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a> *&#160;</td>
          <td class="paramname"><em>read_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>non_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from a file. </p>
<p>If more data is requested than the file contains this function will successfully complete but read_size will be smaller than count</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_inode</td><td>The inode for the file </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to store the data in </td></tr>
    <tr><td class="paramname">file_offset</td><td>The offset in the file to start reading at </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to read </td></tr>
    <tr><td class="paramname">read_size</td><td>A pointer to a variable in which the number of bytes read will be stored </td></tr>
    <tr><td class="paramname">non_block</td><td>Whether to block the call until data is available in the file, this is only supported on FIFO's and character devices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In case of error: a valid error code, Otherwise 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EFAULT</td><td>Atleast one parameter was a NULL pointer </td></tr>
    <tr><td class="paramname">EBADF</td><td>Tried to read from a file for which we do not have permission </td></tr>
    <tr><td class="paramname">EISDIR</td><td>Direct reads from directories are not allowed </td></tr>
    <tr><td class="paramname">EIO</td><td>An IO error was encountered trying to read from the file </td></tr>
    <tr><td class="paramname">EPIPE</td><td>The FIFO has no data left and there are no (open) write endpoints </td></tr>
    <tr><td class="paramname">ENOMEM</td><td>Could not allocate kernel heap for a temporary structure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l00760">760</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="vfs_8h_source.html#l00122">inode::atime</a>, <a class="el" href="blkdev_8c_source.html#l00264">device_block_read()</a>, <a class="el" href="chardev_8c_source.html#l00076">device_char_read()</a>, <a class="el" href="errno_8h_source.html#l00012">EBADF</a>, <a class="el" href="errno_8h_source.html#l00017">EFAULT</a>, <a class="el" href="errno_8h_source.html#l00025">EINVAL</a>, <a class="el" href="errno_8h_source.html#l00024">EISDIR</a>, <a class="el" href="vfs_8h_source.html#l00112">inode::fifo</a>, <a class="el" href="vfs_8h_source.html#l00108">inode::if_dev</a>, <a class="el" href="vfs_8h_source.html#l00116">inode::lock</a>, <a class="el" href="vfs_8h_source.html#l00105">inode::mode</a>, <a class="el" href="vfs_8h_source.html#l00040">MODE_READ</a>, <a class="el" href="pipe_8c_source.html#l00085">pipe_write()</a>, <a class="el" href="stat_8h_source.html#l00026">S_IFBLK</a>, <a class="el" href="stat_8h_source.html#l00030">S_IFCHR</a>, <a class="el" href="stat_8h_source.html#l00028">S_IFDIR</a>, <a class="el" href="stat_8h_source.html#l00032">S_IFIFO</a>, <a class="el" href="stat_8h_source.html#l00020">S_IFMT</a>, <a class="el" href="stat_8h_source.html#l00024">S_IFREG</a>, <a class="el" href="synch_8c_source.html#l00029">semaphore_down()</a>, <a class="el" href="synch_8c_source.html#l00023">semaphore_up()</a>, <a class="el" href="vfs_8h_source.html#l00120">inode::size</a>, <a class="el" href="time_8c_source.html#l00025">system_time</a>, <a class="el" href="vfs_8c_source.html#l00256">vfs_effective_inode()</a>, <a class="el" href="vfs_8c_source.html#l00203">vfs_have_permissions()</a>, <a class="el" href="vfs_8c_source.html#l00115">vfs_inode_release()</a>, and <a class="el" href="vfs_8c_source.html#l00460">vfs_int_read()</a>.</p>

<p>Referenced by <a class="el" href="streams_8c_source.html#l00142">_sys_read()</a>, <a class="el" href="elfloader_8c_source.html#l00025">elf_load()</a>, <a class="el" href="procvmm_8c_source.html#l00224">procvmm_handle_fault()</a>, and <a class="el" href="tar_8c_source.html#l00196">tar_read_record()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6187be67e690be6916a385ebde588093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_rmdir </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the directory to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In case of error: a valid error code, Otherwise 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EFAULT</td><td>Atleast one parameter was a NULL pointer </td></tr>
    <tr><td class="paramname">ENOENT</td><td>The directory does not exist </td></tr>
    <tr><td class="paramname">EEXIST</td><td>The directory still has files in it </td></tr>
    <tr><td class="paramname">EBUSY</td><td>The directory is in use </td></tr>
    <tr><td class="paramname">EIO</td><td>An IO error occurred while deleting the directory </td></tr>
    <tr><td class="paramname">EACCES</td><td>Tried to delete a directory from a directory for which we do not have write permission </td></tr>
    <tr><td class="paramname">ENAMETOOLONG</td><td>The name of the file is longer than the maximum allowed number of characters for a file name </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l01142">1142</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="errno_8h_source.html#l00019">EBUSY</a>, <a class="el" href="errno_8h_source.html#l00020">EEXIST</a>, <a class="el" href="errno_8h_source.html#l00017">EFAULT</a>, <a class="el" href="errno_8h_source.html#l00005">ENOENT</a>, <a class="el" href="vfs_8h_source.html#l00155">dir_cache::inode</a>, <a class="el" href="vfs_8h_source.html#l00116">inode::lock</a>, <a class="el" href="vfs_8h_source.html#l00114">inode::mount</a>, <a class="el" href="process_8h_source.html#l00086">process_info::root_directory</a>, <a class="el" href="scheduler_8c_source.html#l00023">scheduler_current_task</a>, <a class="el" href="synch_8c_source.html#l00029">semaphore_down()</a>, <a class="el" href="synch_8c_source.html#l00023">semaphore_up()</a>, <a class="el" href="vfs_8h_source.html#l00120">inode::size</a>, <a class="el" href="vfs_8c_source.html#l02680">vfs_find_inode()</a>, <a class="el" href="vfs_8c_source.html#l00115">vfs_inode_release()</a>, and <a class="el" href="vfs_8c_source.html#l01789">vfs_unlink()</a>.</p>

<p>Referenced by <a class="el" href="sc__vfs_8c_source.html#l00533">sys_rmdir()</a>.</p>

</div>
</div>
<a class="anchor" id="ga5525864c8ec0cc591c31faf9e0b7636d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_symlink </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>oldpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a symbolic link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldpath</td><td>The target of the link </td></tr>
    <tr><td class="paramname">path</td><td>The path of the link </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In case of error: a valid error code, Otherwise 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EFAULT</td><td>Atleast one parameter was a NULL pointer </td></tr>
    <tr><td class="paramname">ENOENT</td><td>The parent directory does not exist </td></tr>
    <tr><td class="paramname">EEXIST</td><td>A file already exists at the given path </td></tr>
    <tr><td class="paramname">EIO</td><td>An IO error occurred while creating the file </td></tr>
    <tr><td class="paramname">EACCES</td><td>User does not have write permission for the parent dir </td></tr>
    <tr><td class="paramname">ENOSPC</td><td>Not enough disk space was available </td></tr>
    <tr><td class="paramname">ENOMEM</td><td>Could not allocate kernel heap for a temporary structure </td></tr>
    <tr><td class="paramname">ENAMETOOLONG</td><td>The name of the file is longer than the maximum allowed number of characters for a file name </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l01599">1599</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="vfs_8h_source.html#l00122">inode::atime</a>, <a class="el" href="config_8h_source.html#l00010">CONFIG_FILE_MAX_NAME_LENGTH</a>, <a class="el" href="vfs_8h_source.html#l00126">inode::ctime</a>, <a class="el" href="vfs_8h_source.html#l00094">inode::device</a>, <a class="el" href="vfs_8h_source.html#l00092">inode::device_id</a>, <a class="el" href="errno_8h_source.html#l00016">EACCES</a>, <a class="el" href="errno_8h_source.html#l00020">EEXIST</a>, <a class="el" href="errno_8h_source.html#l00017">EFAULT</a>, <a class="el" href="errno_8h_source.html#l00085">ENAMETOOLONG</a>, <a class="el" href="errno_8h_source.html#l00005">ENOENT</a>, <a class="el" href="errno_8h_source.html#l00015">ENOMEM</a>, <a class="el" href="process_8h_source.html#l00076">process_info::gid</a>, <a class="el" href="vfs_8h_source.html#l00103">inode::gid</a>, <a class="el" href="vfs_8h_source.html#l00098">inode::hard_link_count</a>, <a class="el" href="heapmm_8c_source.html#l00552">heapmm_alloc()</a>, <a class="el" href="heapmm_8c_source.html#l00574">heapmm_free()</a>, <a class="el" href="vfs_8h_source.html#l00090">inode::id</a>, <a class="el" href="vfs_8h_source.html#l00108">inode::if_dev</a>, <a class="el" href="vfs_8h_source.html#l00375">fs_device::inode_size</a>, <a class="el" href="vfs_8h_source.html#l00110">inode::link_path</a>, <a class="el" href="llist_8c_source.html#l00078">llist_add_end()</a>, <a class="el" href="llist_8c_source.html#l00093">llist_unlink()</a>, <a class="el" href="vfs_8h_source.html#l00116">inode::lock</a>, <a class="el" href="string_8c_source.html#l00045">memset()</a>, <a class="el" href="vfs_8h_source.html#l00105">inode::mode</a>, <a class="el" href="vfs_8h_source.html#l00045">MODE_WRITE</a>, <a class="el" href="vfs_8h_source.html#l00124">inode::mtime</a>, <a class="el" href="vfs_8h_source.html#l00096">inode::name</a>, <a class="el" href="scheduler_8c_source.html#l00023">scheduler_current_task</a>, <a class="el" href="synch_8c_source.html#l00068">semaphore_alloc()</a>, <a class="el" href="synch_8c_source.html#l00029">semaphore_down()</a>, <a class="el" href="synch_8c_source.html#l00023">semaphore_up()</a>, <a class="el" href="string_8c_source.html#l00065">strcpy()</a>, <a class="el" href="string_8c_source.html#l00038">strlen()</a>, <a class="el" href="time_8c_source.html#l00025">system_time</a>, <a class="el" href="process_8h_source.html#l00075">process_info::uid</a>, <a class="el" href="vfs_8h_source.html#l00101">inode::uid</a>, <a class="el" href="vfs_8c_source.html#l02680">vfs_find_inode()</a>, <a class="el" href="vfs_8c_source.html#l02653">vfs_find_parent()</a>, <a class="el" href="vfs_8c_source.html#l00053">vfs_get_filename()</a>, <a class="el" href="vfs_8c_source.html#l00203">vfs_have_permissions()</a>, <a class="el" href="vfs_8c_source.html#l00157">vfs_inode_cache()</a>, <a class="el" href="vfs_8c_source.html#l00115">vfs_inode_release()</a>, <a class="el" href="vfs_8c_source.html#l00389">vfs_int_link()</a>, <a class="el" href="vfs_8c_source.html#l00321">vfs_int_mknod()</a>, and <a class="el" href="vfs_8c_source.html#l00343">vfs_int_rmnod()</a>.</p>

<p>Referenced by <a class="el" href="sc__vfs_8c_source.html#l00098">sys_symlink()</a>, and <a class="el" href="tar_8c_source.html#l00104">tar_read_record_mem()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9913748fc23c6bfe9d775a2f27d82228"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td>
          <td class="paramname"><em>_inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a>&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a file. </p>
<p>If the new size is larger than the file currently is the new room will be filled with zero bytes, if the new size is smaller the data in the truncated part of the file is deleted</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_inode</td><td>The inode for the file </td></tr>
    <tr><td class="paramname">length</td><td>The new size of the file </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In case of error: a valid error code, Otherwise 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EFAULT</td><td>Atleast one parameter was a NULL pointer </td></tr>
    <tr><td class="paramname">EACCES</td><td>Tried to resize a file for which we do not have permission </td></tr>
    <tr><td class="paramname">EISDIR</td><td>Directories can not be resized </td></tr>
    <tr><td class="paramname">EIO</td><td>An IO error was encountered trying to resize the file </td></tr>
    <tr><td class="paramname">ENOSPC</td><td>The disk was full when trying to grow the file </td></tr>
    <tr><td class="paramname">ENOMEM</td><td>Could not allocate kernel heap for a temporary structure </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l01043">1043</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="errno_8h_source.html#l00016">EACCES</a>, <a class="el" href="errno_8h_source.html#l00017">EFAULT</a>, <a class="el" href="errno_8h_source.html#l00025">EINVAL</a>, <a class="el" href="errno_8h_source.html#l00024">EISDIR</a>, <a class="el" href="vfs_8h_source.html#l00116">inode::lock</a>, <a class="el" href="vfs_8h_source.html#l00105">inode::mode</a>, <a class="el" href="vfs_8h_source.html#l00045">MODE_WRITE</a>, <a class="el" href="vfs_8h_source.html#l00124">inode::mtime</a>, <a class="el" href="stat_8h_source.html#l00026">S_IFBLK</a>, <a class="el" href="stat_8h_source.html#l00030">S_IFCHR</a>, <a class="el" href="stat_8h_source.html#l00028">S_IFDIR</a>, <a class="el" href="stat_8h_source.html#l00032">S_IFIFO</a>, <a class="el" href="stat_8h_source.html#l00020">S_IFMT</a>, <a class="el" href="stat_8h_source.html#l00024">S_IFREG</a>, <a class="el" href="synch_8c_source.html#l00029">semaphore_down()</a>, <a class="el" href="synch_8c_source.html#l00023">semaphore_up()</a>, <a class="el" href="vfs_8h_source.html#l00120">inode::size</a>, <a class="el" href="time_8c_source.html#l00025">system_time</a>, <a class="el" href="vfs_8c_source.html#l00256">vfs_effective_inode()</a>, <a class="el" href="vfs_8c_source.html#l00203">vfs_have_permissions()</a>, <a class="el" href="vfs_8c_source.html#l00115">vfs_inode_release()</a>, and <a class="el" href="vfs_8c_source.html#l00504">vfs_int_truncate()</a>.</p>

<p>Referenced by <a class="el" href="streams_8c_source.html#l00237">_sys_ftruncate()</a>, <a class="el" href="sc__vfs_8c_source.html#l00275">_sys_truncate()</a>, and <a class="el" href="tar_8c_source.html#l00104">tar_read_record_mem()</a>.</p>

</div>
</div>
<a class="anchor" id="ga797ee30a843cc96fdb59db73fe97102d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_unlink </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the file to delete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In case of error: a valid error code, Otherwise 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EFAULT</td><td>Atleast one parameter was a NULL pointer </td></tr>
    <tr><td class="paramname">ENOENT</td><td>The file does not exist </td></tr>
    <tr><td class="paramname">EEXIST</td><td>A file already exists at the given path </td></tr>
    <tr><td class="paramname">EBUSY</td><td>The file is in use </td></tr>
    <tr><td class="paramname">EIO</td><td>An IO error occurred while deleting the file </td></tr>
    <tr><td class="paramname">EACCES</td><td>User does not have write permission for the file </td></tr>
    <tr><td class="paramname">ENOMEM</td><td>Could not allocate kernel heap for a temporary structure </td></tr>
    <tr><td class="paramname">ENAMETOOLONG</td><td>The name of the file is longer than the maximum allowed number of characters for a file name </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l01789">1789</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="config_8h_source.html#l00010">CONFIG_FILE_MAX_NAME_LENGTH</a>, <a class="el" href="vfs_8h_source.html#l00126">inode::ctime</a>, <a class="el" href="vfs_8h_source.html#l00094">inode::device</a>, <a class="el" href="errno_8h_source.html#l00016">EACCES</a>, <a class="el" href="errno_8h_source.html#l00019">EBUSY</a>, <a class="el" href="errno_8h_source.html#l00017">EFAULT</a>, <a class="el" href="errno_8h_source.html#l00085">ENAMETOOLONG</a>, <a class="el" href="errno_8h_source.html#l00005">ENOENT</a>, <a class="el" href="vfs_8h_source.html#l00098">inode::hard_link_count</a>, <a class="el" href="heapmm_8c_source.html#l00574">heapmm_free()</a>, <a class="el" href="vfs_8h_source.html#l00375">fs_device::inode_size</a>, <a class="el" href="llist_8c_source.html#l00093">llist_unlink()</a>, <a class="el" href="vfs_8h_source.html#l00116">inode::lock</a>, <a class="el" href="vfs_8h_source.html#l00045">MODE_WRITE</a>, <a class="el" href="synch_8c_source.html#l00029">semaphore_down()</a>, <a class="el" href="synch_8c_source.html#l00023">semaphore_up()</a>, <a class="el" href="string_8c_source.html#l00038">strlen()</a>, <a class="el" href="time_8c_source.html#l00025">system_time</a>, <a class="el" href="vfs_8h_source.html#l00118">inode::usage_count</a>, <a class="el" href="vfs_8c_source.html#l02653">vfs_find_parent()</a>, <a class="el" href="vfs_8c_source.html#l02708">vfs_find_symlink()</a>, <a class="el" href="vfs_8c_source.html#l00053">vfs_get_filename()</a>, <a class="el" href="vfs_8c_source.html#l00203">vfs_have_permissions()</a>, <a class="el" href="vfs_8c_source.html#l00115">vfs_inode_release()</a>, <a class="el" href="vfs_8c_source.html#l00343">vfs_int_rmnod()</a>, and <a class="el" href="vfs_8c_source.html#l00412">vfs_int_unlink()</a>.</p>

<p>Referenced by <a class="el" href="sc__vfs_8c_source.html#l00131">sys_unlink()</a>, <a class="el" href="vfs_8c_source.html#l01201">vfs_mkdir()</a>, and <a class="el" href="vfs_8c_source.html#l01142">vfs_rmdir()</a>.</p>

</div>
</div>
<a class="anchor" id="gab379ab04ee753835803908fe8e2390ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vfs_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__vfs.html#ga2dd256afc91a2d7a99e2082e096664b2">inode_t</a> *&#160;</td>
          <td class="paramname"><em>_inode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a>&#160;</td>
          <td class="paramname"><em>file_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8h.html#a2ecffc95171f097e4c966c8a29fbe038">aoff_t</a> *&#160;</td>
          <td class="paramname"><em>write_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>non_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a file. </p>
<p>If the data to be written would extend past the end of the file, the file will grow. If file_offset lies past the end of the file, the file will grow and the resulting gap will be filled with zero bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_inode</td><td>The inode for the file </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer containing the data to write </td></tr>
    <tr><td class="paramname">file_offset</td><td>The offset in the file to start writing at </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to write </td></tr>
    <tr><td class="paramname">write_size</td><td>A pointer to a variable in which the number of bytes written will be stored </td></tr>
    <tr><td class="paramname">non_block</td><td>Whether to block the call until room is available in the file, this is only supported on FIFO's and character devices </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In case of error: a valid error code, Otherwise 0</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EFAULT</td><td>Atleast one parameter was a NULL pointer </td></tr>
    <tr><td class="paramname">EBADF</td><td>Tried to write to a file for which we do not have permission </td></tr>
    <tr><td class="paramname">EISDIR</td><td>Direct writes to directories are not allowed </td></tr>
    <tr><td class="paramname">EIO</td><td>An IO error was encountered trying to write to the file </td></tr>
    <tr><td class="paramname">EPIPE</td><td>The FIFO has no room left and there are no (open) read endpoints </td></tr>
    <tr><td class="paramname">ENOSPC</td><td>The disk was full when trying to write to the file </td></tr>
    <tr><td class="paramname">ENOMEM</td><td>Could not allocate kernel heap for a temporary structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000083">Todo:</a></b></dt><dd>: Make this more efficient, implement sparse files </dd></dl>

<p>Definition at line <a class="el" href="vfs_8c_source.html#l00553">553</a> of file <a class="el" href="vfs_8c_source.html">vfs.c</a>.</p>

<p>References <a class="el" href="blkdev_8c_source.html#l00182">device_block_write()</a>, <a class="el" href="chardev_8c_source.html#l00066">device_char_write()</a>, <a class="el" href="errno_8h_source.html#l00012">EBADF</a>, <a class="el" href="errno_8h_source.html#l00017">EFAULT</a>, <a class="el" href="errno_8h_source.html#l00025">EINVAL</a>, <a class="el" href="errno_8h_source.html#l00024">EISDIR</a>, <a class="el" href="vfs_8h_source.html#l00112">inode::fifo</a>, <a class="el" href="heapmm_8c_source.html#l00552">heapmm_alloc()</a>, <a class="el" href="heapmm_8c_source.html#l00574">heapmm_free()</a>, <a class="el" href="vfs_8h_source.html#l00108">inode::if_dev</a>, <a class="el" href="vfs_8h_source.html#l00116">inode::lock</a>, <a class="el" href="string_8c_source.html#l00045">memset()</a>, <a class="el" href="vfs_8h_source.html#l00105">inode::mode</a>, <a class="el" href="vfs_8h_source.html#l00045">MODE_WRITE</a>, <a class="el" href="vfs_8h_source.html#l00124">inode::mtime</a>, <a class="el" href="pipe_8c_source.html#l00085">pipe_write()</a>, <a class="el" href="stat_8h_source.html#l00026">S_IFBLK</a>, <a class="el" href="stat_8h_source.html#l00030">S_IFCHR</a>, <a class="el" href="stat_8h_source.html#l00028">S_IFDIR</a>, <a class="el" href="stat_8h_source.html#l00032">S_IFIFO</a>, <a class="el" href="stat_8h_source.html#l00020">S_IFMT</a>, <a class="el" href="stat_8h_source.html#l00024">S_IFREG</a>, <a class="el" href="synch_8c_source.html#l00029">semaphore_down()</a>, <a class="el" href="synch_8c_source.html#l00023">semaphore_up()</a>, <a class="el" href="vfs_8h_source.html#l00120">inode::size</a>, <a class="el" href="time_8c_source.html#l00025">system_time</a>, <a class="el" href="vfs_8c_source.html#l00256">vfs_effective_inode()</a>, <a class="el" href="vfs_8c_source.html#l00203">vfs_have_permissions()</a>, <a class="el" href="vfs_8c_source.html#l00115">vfs_inode_release()</a>, and <a class="el" href="vfs_8c_source.html#l00481">vfs_int_write()</a>.</p>

<p>Referenced by <a class="el" href="streams_8c_source.html#l00192">_sys_write()</a>, <a class="el" href="tar_8c_source.html#l00196">tar_read_record()</a>, and <a class="el" href="tar_8c_source.html#l00104">tar_read_record_mem()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Jul 13 2014 03:25:30 for posnk kernel by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
